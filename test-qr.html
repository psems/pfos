<!--
  PFOS QR Code Validation Test Page
  ==================================
  Generates QR codes with known content and scans them back using html5-qrcode
  to verify round-trip correctness. Open in a browser to run.
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PFOS - QR Code Validation Tests</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: 'Fira Mono', 'Consolas', 'Courier New', monospace;
      background: #000;
      color: #00ff00;
      padding: 1em;
    }
    h2 { text-shadow: 0 0 12px #00ff00; }
    .test-result {
      padding: 8px 12px;
      margin: 4px 0;
      border-left: 4px solid #555;
      background: #0a0a0a;
    }
    .test-result.pass { border-left-color: #00ff00; }
    .test-result.fail { border-left-color: #ff0000; color: #ff4444; }
    .test-result.skip { border-left-color: #ffaa00; color: #ffaa00; }
    #summary {
      margin-top: 1em;
      padding: 12px;
      border: 2px solid #00ff00;
      font-size: 1.2em;
    }
    #summary.all-pass { border-color: #00ff00; }
    #summary.has-fail { border-color: #ff0000; color: #ff4444; }
    #test-workspace { position: absolute; left: -9999px; top: 0; }
    button {
      background: #111;
      color: #00ff00;
      border: 1px solid #00ff00;
      padding: 0.5em 1em;
      cursor: pointer;
      font-family: inherit;
      font-size: 1em;
      margin: 0.5em;
    }
    button:hover { background: #003300; }
    #progress { margin: 1em 0; }
  </style>
  <script src="qrcode.min.js"></script>
  <script src="html5-qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>
</head>
<body>
  <h2>PFOS QR Validation Tests</h2>
  <button id="run-btn" onclick="runAllTests()">Run All Tests</button>
  <div id="progress"></div>
  <div id="results"></div>
  <div id="summary"></div>
  <!-- Off-screen workspace for generating QR codes -->
  <div id="test-workspace">
    <div id="test-qr"></div>
    <svg id="test-barcode"></svg>
  </div>

  <script>
    const resultsDiv = document.getElementById('results');
    const summaryDiv = document.getElementById('summary');
    const progressDiv = document.getElementById('progress');
    let passed = 0, failed = 0, skipped = 0;

    function logResult(name, status, detail) {
      const div = document.createElement('div');
      div.className = `test-result ${status}`;
      const icon = status === 'pass' ? '[PASS]' : status === 'fail' ? '[FAIL]' : '[SKIP]';
      div.textContent = `${icon} ${name}${detail ? ' â€” ' + detail : ''}`;
      resultsDiv.appendChild(div);
      if (status === 'pass') passed++;
      else if (status === 'fail') failed++;
      else skipped++;
    }

    function updateProgress(current, total) {
      progressDiv.textContent = `Running test ${current}/${total}...`;
    }

    // Generate a QR code into a canvas and return the canvas element
    function generateTestQR(text, targetId) {
      return new Promise((resolve, reject) => {
        const container = document.getElementById(targetId);
        container.innerHTML = '';
        try {
          new QRCode(container, {
            text: text,
            width: 256,
            height: 256,
            colorDark: "#000000",
            colorLight: "#ffffff",
            correctLevel: QRCode.CorrectLevel.M,
            quietZone: 10,
            quietZoneColor: "#ffffff"
          });
          // QRCode library renders asynchronously via image; wait for the canvas/img
          setTimeout(() => {
            const canvas = container.querySelector('canvas');
            const img = container.querySelector('img');
            if (canvas) {
              resolve(canvas);
            } else if (img) {
              // Convert img to canvas for scanning
              const c = document.createElement('canvas');
              c.width = img.naturalWidth || 256;
              c.height = img.naturalHeight || 256;
              const ctx = c.getContext('2d');
              img.onload = () => {
                ctx.drawImage(img, 0, 0);
                resolve(c);
              };
              if (img.complete) {
                ctx.drawImage(img, 0, 0);
                resolve(c);
              }
            } else {
              reject(new Error('QR code not rendered'));
            }
          }, 300);
        } catch (err) {
          reject(err);
        }
      });
    }

    // Scan a QR code from a canvas element and return the decoded text
    function scanQRFromCanvas(canvas) {
      return new Promise((resolve, reject) => {
        canvas.toBlob(blob => {
          if (!blob) {
            reject(new Error('Failed to convert canvas to blob'));
            return;
          }
          const file = new File([blob], 'test-qr.png', { type: 'image/png' });
          const scanner = new Html5Qrcode('test-qr-scanner-' + Date.now());
          // Create a temporary div for the scanner
          const tmpDiv = document.createElement('div');
          tmpDiv.id = scanner.elementId || 'tmp-scanner-' + Date.now();
          tmpDiv.style.display = 'none';
          document.body.appendChild(tmpDiv);

          const scannerInstance = new Html5Qrcode(tmpDiv.id);
          scannerInstance.scanFile(file, true)
            .then(decodedText => {
              scannerInstance.clear();
              tmpDiv.remove();
              resolve(decodedText);
            })
            .catch(err => {
              scannerInstance.clear();
              tmpDiv.remove();
              reject(err);
            });
        }, 'image/png');
      });
    }

    // Round-trip test: generate QR, scan it back, compare
    async function testQRRoundTrip(name, inputText) {
      try {
        const canvas = await generateTestQR(inputText, 'test-qr');
        const decoded = await scanQRFromCanvas(canvas);
        if (decoded === inputText) {
          logResult(name, 'pass', `"${inputText.substring(0, 50)}${inputText.length > 50 ? '...' : ''}"`);
        } else {
          logResult(name, 'fail', `Expected "${inputText.substring(0, 50)}" but got "${decoded.substring(0, 50)}"`);
        }
      } catch (err) {
        logResult(name, 'fail', err.message);
      }
    }

    // Test that 1D barcode generation doesn't throw
    function testBarcodeGeneration(name, text, format) {
      try {
        const svg = document.getElementById('test-barcode');
        svg.innerHTML = '';
        JsBarcode('#test-barcode', text, {
          format: format,
          width: 2,
          height: 100,
          displayValue: true
        });
        // Check that SVG has content
        if (svg.querySelector('rect') || svg.querySelector('path') || svg.innerHTML.length > 50) {
          logResult(name, 'pass', `Generated ${format} for "${text}"`);
        } else {
          logResult(name, 'fail', `SVG appears empty for ${format}`);
        }
      } catch (err) {
        logResult(name, 'fail', err.message);
      }
    }

    // Test input validation logic (mirrors generateQRCode validation)
    function testValidation(name, text, format, shouldPass) {
      let valid = true;
      let reason = '';

      if (!text || typeof text !== 'string') {
        valid = false;
        reason = 'empty or non-string input';
      } else if (['UPC_A', 'UPC_E', 'EAN_13', 'EAN_8'].includes(format)) {
        if (!/^\d+$/.test(text)) {
          valid = false;
          reason = 'non-numeric for UPC/EAN';
        }
        const lengths = { 'UPC_A': 11, 'UPC_E': 7, 'EAN_13': 12, 'EAN_8': 7 };
        if (lengths[format] && text.length !== lengths[format]) {
          valid = false;
          reason = `wrong length: ${text.length} (need ${lengths[format]})`;
        }
      } else if (text.length > 4000) {
        valid = false;
        reason = 'exceeds max length';
      }

      if (valid === shouldPass) {
        logResult(name, 'pass', reason || 'validation correct');
      } else {
        logResult(name, 'fail', `Expected ${shouldPass ? 'valid' : 'invalid'}, got ${valid ? 'valid' : 'invalid'}: ${reason}`);
      }
    }

    async function runAllTests() {
      document.getElementById('run-btn').disabled = true;
      resultsDiv.innerHTML = '';
      summaryDiv.innerHTML = '';
      passed = 0;
      failed = 0;
      skipped = 0;

      const tests = [];
      let testIndex = 0;

      // === QR Code Round-Trip Tests ===
      const qrTests = [
        ['QR: simple text', 'Hello World'],
        ['QR: URL', 'https://github.com/psems/pfos'],
        ['QR: numeric', '1234567890'],
        ['QR: special characters', 'Test!@#$%^&*()'],
        ['QR: spaces and punctuation', 'The quick brown fox jumps over the lazy dog.'],
        ['QR: unicode', 'Caf\u00e9 na\u00efve r\u00e9sum\u00e9'],
        ['QR: long text', 'A'.repeat(200)],
        ['QR: single character', 'X'],
        ['QR: mixed case', 'AbCdEfGhIjKlMnOpQrStUvWxYz'],
        ['QR: newlines', 'Line1\nLine2\nLine3'],
        ['QR: JSON-like', '{"key":"value","num":42}'],
        ['QR: email', 'user@example.com'],
        ['QR: whitespace preserved', '  leading and trailing  '],
      ];

      const totalTests = qrTests.length + 9 + 10; // QR + barcode + validation

      for (const [name, text] of qrTests) {
        testIndex++;
        updateProgress(testIndex, totalTests);
        await testQRRoundTrip(name, text);
        // Small delay between tests to avoid DOM thrashing
        await new Promise(r => setTimeout(r, 100));
      }

      // === 1D Barcode Generation Tests ===
      const barcodeTests = [
        ['Barcode: Code128 alphanumeric', 'ABC-123', 'CODE128'],
        ['Barcode: Code128 text', 'Hello World', 'CODE128'],
        ['Barcode: Code39 uppercase', 'HELLO123', 'CODE39'],
        ['Barcode: EAN13', '590123412345', 'EAN13'],
        ['Barcode: EAN8', '9638507', 'EAN8'],
        ['Barcode: UPC-A', '01234567890', 'UPC'],
        ['Barcode: ITF even digits', '12345678', 'ITF'],
        ['Barcode: Codabar', 'A12345B', 'codabar'],
        ['Barcode: Code93', 'TEST93', 'CODE93'],
      ];

      for (const [name, text, format] of barcodeTests) {
        testIndex++;
        updateProgress(testIndex, totalTests);
        testBarcodeGeneration(name, text, format);
      }

      // === Input Validation Tests ===
      testIndex++; updateProgress(testIndex, totalTests);
      testValidation('Validate: empty string rejected', '', 'QR_CODE', false);
      testIndex++; updateProgress(testIndex, totalTests);
      testValidation('Validate: normal text accepted', 'Hello', 'QR_CODE', true);
      testIndex++; updateProgress(testIndex, totalTests);
      testValidation('Validate: EAN-13 correct length', '590123412345', 'EAN_13', true);
      testIndex++; updateProgress(testIndex, totalTests);
      testValidation('Validate: EAN-13 wrong length rejected', '12345', 'EAN_13', false);
      testIndex++; updateProgress(testIndex, totalTests);
      testValidation('Validate: EAN-13 non-numeric rejected', 'ABCDEFGHIJKL', 'EAN_13', false);
      testIndex++; updateProgress(testIndex, totalTests);
      testValidation('Validate: UPC-A correct length', '01234567890', 'UPC_A', true);
      testIndex++; updateProgress(testIndex, totalTests);
      testValidation('Validate: UPC-A wrong length rejected', '123', 'UPC_A', false);
      testIndex++; updateProgress(testIndex, totalTests);
      testValidation('Validate: EAN-8 correct length', '9638507', 'EAN_8', true);
      testIndex++; updateProgress(testIndex, totalTests);
      testValidation('Validate: over 4000 chars rejected', 'X'.repeat(4001), 'QR_CODE', false);
      testIndex++; updateProgress(testIndex, totalTests);
      testValidation('Validate: exactly 4000 chars accepted', 'X'.repeat(4000), 'QR_CODE', true);

      // === Summary ===
      progressDiv.textContent = 'Done.';
      const total = passed + failed + skipped;
      summaryDiv.textContent = `Results: ${passed}/${total} passed, ${failed} failed, ${skipped} skipped`;
      summaryDiv.className = failed > 0 ? 'has-fail' : 'all-pass';
      document.getElementById('run-btn').disabled = false;
    }
  </script>
</body>
</html>
