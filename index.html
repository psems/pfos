<!--
Pocket Full of Sunshine
======================
An open source, mobile-first QR code utility for generating, incrementing, and cloning QR codes in the browser.

Author: GrandMasterFunk
License: MIT
Repository: https://github.com/psems/pfos
Version: 0.0.7
Date: 2025-06-27

Description:
  - Mobile-first, browser-based tool for generating QR codes from text, incrementing numbers, or cloning existing QR codes via camera scan.
  - Features: logging, marking, download log, no backend required, hacker/terminal theme, accessibility and security reviewed.

Usage:
  1. Select a mode: Text, Increment, or Clone QR
  2. Enter your data or scan a QR code
  3. Generate and interact with QR codes directly in your browser
  4. Mark and download your QR code log for record-keeping

Accessibility & Security:
  - All interactive elements are keyboard accessible.
  - Camera access requires HTTPS and user permission.
  - No user data is sent to a server; all processing is local.
  - Libraries are self-hosted for reliability.

Optimized for:
  - Mobile browsers (iOS Safari, Android Chrome, Firefox)
  - Fast load, minimal dependencies, responsive layout
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pocket Full of Sunshine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#00ff00">
  <link rel="stylesheet" href="style.css">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  
  <!-- Load QR code libraries -->
  <script src="qrcode.min.js"></script>
  <script src="html5-qrcode.min.js"></script>
</head>
<body>
  <h2>Pocket Full of Sunshine</h2>
  <!--
    Mode selection: Clone QR (scan or edit), Increment (number series), Text (free text)
    Uses a select for accessibility and mobile compatibility.
  -->
  <select id="mode-select" aria-label="Select QR mode">
    <option value="clone" selected>Clone QR</option>
    <option value="increment">Increment</option>
    <option value="text">Text</option>
  </select>
  <!-- Text mode: free text to QR code -->
  <div id="text-mode">
    <input type="text" id="text-input" placeholder="Enter text" value="Groovy!" inputmode="text" aria-label="Text to encode">
    <button onclick="generateTextQR()">Generate QR</button>
  </div>
  <!-- Increment mode: generate a series of QR codes -->
  <div id="increment-mode" class="hidden">
    <input type="number" id="start-number" placeholder="Start number" inputmode="numeric" pattern="[0-9]*"  aria-label="Start number">
    <input type="number" id="increment-step" placeholder="Step" inputmode="numeric" pattern="[0-9]*" aria-label="Increment step">
    <button onclick="startIncrementQR()">Generate QR</button>
  </div>
  <!-- Clone mode: scan or edit QR code content -->
  <div id="clone-mode">
    <div id="reader"></div>
    <input type="text" id="clone-input" placeholder="Scan or edit QR content" value="CLONE ME!" aria-label="Cloned QR content">
    <div class="upload-section">
      <label for="clone-file-input" class="file-upload-label">Upload QR Image</label>
      <input type="file" id="clone-file-input" accept="image/*" aria-label="Upload QR image">
      <span class="file-format-hint">(Supports: PNG, JPG, GIF)</span>
    </div>
    <button id="generate-clone-btn" onclick="generateCloneQR()">Generate QR</button>
    <button id="scan-qr-btn" type="button" onclick="startCamera()">Scan QR Code</button>
    <button id="cancel-scan-btn" type="button" onclick="stopCamera()">Cancel Scan</button>
  </div>
  <div id="qr"></div>
  <button id="increment-btn" class="hidden" onclick="incrementAndGenerateQR()">INCREMENT</button>
  <button id="mark-btn" onclick="markCurrent()">MARK</button>
  <button onclick="downloadLog()">Download Log</button>
  <!-- Log output: bash-style, accessible, resizable -->
  <textarea id="log" readonly aria-label="QR code log" placeholder="QR code log will appear here"></textarea>
  <script>
    // Register service worker for PWA support
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('service-worker.js');
      });
    }
  </script>
  <script>
    // --- QR Utility Main Script ---
    // All logic is client-side, no data leaves the device.
    let qr;
    let currentNumber = 0;
    let incrementStep = 1;
    let isIncrementMode = false;
    let currentValue = '';
    const logArea = document.getElementById('log');
    // Clear the QR code display
    function clearQR() {
      document.getElementById('qr').innerHTML = "";
    }
    // Log an entry to the log textarea, with date/time and optional mark
    function logEntry(value, marked = false, dateOnly = false) {
      let entry;
      if (dateOnly) {
        // Log only the date in YYYY-MM-DD format
        const date = new Date().toISOString().slice(0, 10);
        entry = `--- ${date} ---`;
      } else {
        // Log time in 24-hour format
        const now = new Date();
        const time = now.toLocaleTimeString('en-GB', { hour12: false });
        entry = `${time} - ${value}${marked ? " [MARKED]" : ""}`;
      }
      logArea.value += entry + "\n";
      logArea.scrollTop = logArea.scrollHeight;
    }
    // Helper function to generate QR codes with validation and error handling
    function generateQRCode(text, prefix = '') {
      // Check if QR library is available
      if (typeof QRCode === 'undefined') {
        console.error('QR library not loaded');
        alert('QR library not loaded. Please refresh the page.');
        return false;
      }

      // Input validation
      if (!text || typeof text !== 'string') {
        console.error('Invalid QR code content');
        alert('Please enter valid content for the QR code');
        return false;
      }

      // Check content length (QR code version 40 can store up to 7,089 numeric characters or 4,296 alphanumeric characters)
      const maxLength = 4000; // Safe limit for all types
      if (text.length > maxLength) {
        console.error('QR code content too long');
        alert(`QR code content must be less than ${maxLength} characters`);
        return false;
      }

      try {
        clearQR();
        const encodedText = encodeURIComponent(text);  // Ensure consistent UTF-8 encoding
        qr = new QRCode(document.getElementById("qr"), {
          text: encodedText,
          width: 256,
          height: 256,
          colorDark: "#00ff00",
          colorLight: "#000000",
          correctLevel: QRCode.CorrectLevel.M, // Medium error correction for better compatibility
          quietZone: 10,
          quietZoneColor: "#000000"
        });
        currentValue = text;
        logEntry(prefix + text);
        return true;
      } catch (error) {
        console.error('QR code generation failed:', error);
        alert('Failed to generate QR code. Please try again with different content.');
        return false;
      }
    }

    // Generate a QR code from text input
    function generateTextQR() {
      isIncrementMode = false;
      const text = document.getElementById('text-input').value.trim();
      generateQRCode(text);
    }

    // Start increment mode and generate the first QR code
    function startIncrementQR() {
      const startNum = document.getElementById('start-number').value;
      const step = document.getElementById('increment-step').value;
      
      // Validate numeric inputs
      if (!startNum || !step || isNaN(startNum) || isNaN(step)) {
        alert('Please enter valid numbers for start and step values');
        return;
      }

      isIncrementMode = true;
      currentNumber = parseInt(startNum, 10);
      incrementStep = parseInt(step, 10);
      generateIncrementQR();
    }

    // Generate a QR code for the current increment value
    function generateIncrementQR() {
      generateQRCode(currentNumber.toString());
    }

    // Mark the current QR code in the log
    function markCurrent() {
      if (currentValue !== '') {
        logEntry(currentValue, true);
      }
    }

    // Download the log as a text file
    function downloadLog() {
      const blob = new Blob([logArea.value], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'qr-log.txt';
      a.click();
      URL.revokeObjectURL(url);
    }

    // Generate a QR code from the clone input (scanned or edited)
    function generateCloneQR() {
      const text = document.getElementById('clone-input').value.trim();
      generateQRCode(text, 'Cloned: ');
    }
    // Increment the value and generate the next QR code
    function incrementAndGenerateQR() {
      if (isIncrementMode) {
        currentNumber += incrementStep;
        generateIncrementQR();
      }
    }

    document.getElementById('mode-select').addEventListener('change', function () {
      ['text', 'increment', 'clone'].forEach(mode => {
        document.getElementById(`${mode}-mode`).classList.add('hidden');
      });

      const selected = this.value;
      document.getElementById(`${selected}-mode`).classList.remove('hidden');
      clearQR();

      // Log the date when changing mode
      logEntry('', false, true);

      // Show or hide the increment button
      document.getElementById('increment-btn').classList.toggle('hidden', selected !== 'increment');

      const scanBtn = document.getElementById('scan-qr-btn');
      const cancelBtn = document.getElementById('cancel-scan-btn');
      if (scanBtn) scanBtn.style.display = (selected === 'clone') ? '' : 'none';
      if (cancelBtn) cancelBtn.style.display = 'none';

      if (selected === 'clone') {
        generateCloneQR();
        stopCamera();
      } else if (selected === 'increment') {
        startIncrementQR();
      } else {
        generateTextQR();
      }
      if (selected !== 'clone') {
        stopCamera();
      }
    });

    // Request and monitor permissions
    async function requestPermissions() {
      const permissions = [];
      let permissionStatus = {
        camera: 'unknown',
        location: 'unknown'
      };

      // Check and request camera permission
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        permissions.push(
          navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
            .then(() => {
              permissionStatus.camera = 'granted';
              logEntry('Camera permission granted');
            })
            .catch(err => {
              permissionStatus.camera = 'denied';
              logEntry('Camera permission denied or not available: ' + err.message);
            })
        );
      }

      // Check and request location permission
      if (navigator.geolocation) {
        permissions.push(
          new Promise((resolve) => {
            navigator.geolocation.getCurrentPosition(
              () => {
                permissionStatus.location = 'granted';
                logEntry('Location permission granted');
                resolve();
              },
              (err) => {
                permissionStatus.location = 'denied';
                logEntry('Location permission denied or not available: ' + err.message);
                resolve();
              },
              { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
            );
          })
        );
      }

      // Monitor permission changes if supported
      if (navigator.permissions) {
        try {
          const cameraPermission = await navigator.permissions.query({ name: 'camera' });
          cameraPermission.addEventListener('change', () => {
            logEntry(`Camera permission changed to: ${cameraPermission.state}`);
            permissionStatus.camera = cameraPermission.state;
          });
        } catch (e) {
          console.log('Camera permission monitoring not supported');
        }

        try {
          const locationPermission = await navigator.permissions.query({ name: 'geolocation' });
          locationPermission.addEventListener('change', () => {
            logEntry(`Location permission changed to: ${locationPermission.state}`);
            permissionStatus.location = locationPermission.state;
          });
        } catch (e) {
          console.log('Location permission monitoring not supported');
        }
      }

      await Promise.allSettled(permissions);
      return permissionStatus;
    }

    // Initialize the application and generate default QR code
    window.addEventListener('DOMContentLoaded', () => {
      // Set default values
      const defaultMode = 'clone';
      const defaultCloneText = 'CLONE ME!';
      
      // Request permissions early
      requestPermissions().then(status => {
        logEntry(`Initial permissions - Camera: ${status.camera}, Location: ${status.location}`);
      });
      
      // Initialize UI state
      document.getElementById('mode-select').value = defaultMode;
      document.getElementById('clone-input').value = defaultCloneText;
      
      // Hide all mode divs initially
      ['text', 'increment', 'clone'].forEach(mode => {
        document.getElementById(`${mode}-mode`).classList.add('hidden');
      });
      
      // Show only the selected mode
      document.getElementById('clone-mode').classList.remove('hidden');
      clearQR();
      
      // Configure buttons based on mode
      document.getElementById('increment-btn').classList.add('hidden');
      const scanBtn = document.getElementById('scan-qr-btn');
      const cancelBtn = document.getElementById('cancel-scan-btn');
      if (scanBtn) scanBtn.style.display = '';
      if (cancelBtn) cancelBtn.style.display = 'none';
      
      // Generate initial QR code with error handling
      try {
        generateCloneQR();
        stopCamera();
      } catch (error) {
        console.error('Failed to generate initial QR code:', error);
        alert('Failed to initialize QR code. Please refresh the page.');
      }
      
      // Log the date on initial load
      logEntry('', false, true);
    });

    let scanner;

    function startCamera() {
      stopCamera();
      const scanBtn = document.getElementById('scan-qr-btn');
      const cancelBtn = document.getElementById('cancel-scan-btn');
      if (scanBtn) scanBtn.style.display = 'none';
      if (cancelBtn) {
        cancelBtn.style.display = '';
      }
      const readerDiv = document.getElementById('reader');
      readerDiv.innerHTML = '';
      readerDiv.classList.remove('hidden');
      if (typeof Html5Qrcode === 'undefined') {
        alert('QR scanner library not loaded.');
        console.error('Html5Qrcode is undefined.');
        if (scanBtn) scanBtn.style.display = '';
        if (cancelBtn) {
          cancelBtn.classList.add('hidden');
          cancelBtn.style.display = 'none';
        }
        return;
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert('Camera API not supported in this browser.');
        console.error('mediaDevices.getUserMedia not available.');
        if (scanBtn) scanBtn.style.display = '';
        if (cancelBtn) cancelBtn.style.display = 'none';
        return;
      }
      if (typeof navigator.permissions !== 'undefined' && navigator.permissions.query) {
        navigator.permissions.query({ name: 'camera' }).then(function(result) {
          console.log('Camera permission state:', result.state);
        }).catch(function(e) {
          console.log('Camera permission query not supported:', e);
        });
      }
      try {
        scanner = new Html5Qrcode("reader");
        scanner.start({ facingMode: { exact: "environment" } }, {
          fps: 10,
          qrbox: 250,
          experimentalFeatures: {
            useBarCodeDetectorIfSupported: true // Enable broader QR code support
          },
          formatsToSupport: [ // Support all formats
            Html5QrcodeSupportedFormats.QR_CODE,
            Html5QrcodeSupportedFormats.AZTEC,
            Html5QrcodeSupportedFormats.DATA_MATRIX,
            Html5QrcodeSupportedFormats.PDF_417,
            Html5QrcodeSupportedFormats.CODE_128,
            Html5QrcodeSupportedFormats.CODE_93,
            Html5QrcodeSupportedFormats.CODE_39,
            Html5QrcodeSupportedFormats.CODABAR,
            Html5QrcodeSupportedFormats.EAN_13,
            Html5QrcodeSupportedFormats.EAN_8,
            Html5QrcodeSupportedFormats.ITF,
            Html5QrcodeSupportedFormats.UPC_A,
            Html5QrcodeSupportedFormats.UPC_E
          ]
        }, (qrCodeMessage, decodedResult) => {
          // Try to decode if it's URL encoded, otherwise use as-is
          let decodedMessage;
          try {
            decodedMessage = decodeURIComponent(qrCodeMessage.trim());
          } catch (e) {
            // If decoding fails, use the original message
            decodedMessage = qrCodeMessage.trim();
          }
          const cleanedMessage = decodedMessage.replace(/[\x00-\x1F\x7F-\x9F]/g, '');
          document.getElementById('clone-input').value = cleanedMessage;
          // Get the format of the scanned code
          const format = decodedResult.result.format.formatName || 'Unknown';
          // Try to get geolocation and log with QR
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function(pos) {
              const coords = pos.coords;
              const lat = coords.latitude.toFixed(6);
              const lon = coords.longitude.toFixed(6);
              const loc = `@(${lat},${lon})`;
              // Try to fetch nearest address from Nominatim OpenStreetMap
              fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}`)
                .then(r => r.json())
                .then(data => {
                  let address = '';
                  if (data && data.display_name) {
                    address = ` [${data.display_name}]`;
                  } else {
                    address = ' [Address unavailable]';
                  }
                  generateQRCode(cleanedMessage, `Cloned [Format: ${format}] ${loc}${address}: `);
                  stopCamera();
                })
                .catch(() => {
                  generateQRCode(cleanedMessage, `Cloned [Format: ${format}] ${loc} [Address lookup failed]: `);
                  stopCamera();
                });
            }, function(err) {
              generateQRCode(cleanedMessage, `Cloned [Format: ${format}] [Location unavailable]: `);
              stopCamera();
            }, { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 });
          } else {
            generateQRCode(cleanedMessage, `Cloned [Format: ${format}] [Location unsupported]: `);
            stopCamera();
            stopCamera();
          }
        }).catch(err => {
          const errorDetails = {
            type: err.name || 'Unknown',
            message: err.message || 'No error message',
            stack: err.stack || 'No stack trace',
            timestamp: new Date().toISOString(),
            browser: navigator.userAgent,
            https: window.location.protocol === 'https:',
            camera: {
              mediaDevices: !!navigator.mediaDevices,
              getUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
              permissions: typeof navigator.permissions !== 'undefined'
            }
          };
          console.error('Camera start error:', errorDetails);
          logEntry(`Camera error: ${errorDetails.type} - ${errorDetails.message}`);
          alert("Camera access failed. Please check permissions, HTTPS, and try refreshing the page.\nError: " + err);
          stopCamera();
        });
      } catch (err) {
        const errorDetails = {
          type: err.name || 'Unknown',
          message: err.message || 'No error message',
          stack: err.stack || 'No stack trace',
          timestamp: new Date().toISOString(),
          scanner: typeof Html5Qrcode !== 'undefined' ? 'loaded' : 'not loaded',
          reader: document.getElementById('reader') ? 'exists' : 'not found'
        };
        console.error('Camera init error:', errorDetails);
        logEntry(`Camera init error: ${errorDetails.type} - ${errorDetails.message}`);
        alert("Camera initialization failed.\nError: " + err);
        if (scanBtn) scanBtn.style.display = '';
        if (cancelBtn) cancelBtn.style.display = 'none';
      }
    }

    function stopCamera() {
      const readerDiv = document.getElementById('reader');
      const scanBtn = document.getElementById('scan-qr-btn');
      const cancelBtn = document.getElementById('cancel-scan-btn');
      if (scanner) {
        scanner.stop().then(() => {
          scanner.clear();
          scanner = null;
          if (readerDiv) readerDiv.innerHTML = '';
          if (scanBtn && document.getElementById('mode-select').value === 'clone') scanBtn.style.display = '';
          if (cancelBtn) cancelBtn.style.display = '';
        }).catch(err => {
          console.error('Camera stop error:', err);
          scanner = null;
          if (readerDiv) readerDiv.innerHTML = '';
          if (scanBtn && document.getElementById('mode-select').value === 'clone') scanBtn.style.display = '';
          if (cancelBtn) cancelBtn.style.display = '';
        });
      } else {
        if (readerDiv) readerDiv.innerHTML = '';
        if (scanBtn && document.getElementById('mode-select').value === 'clone') scanBtn.style.display = '';
        if (cancelBtn) cancelBtn.style.display = '';
      }
      if (readerDiv && document.getElementById('mode-select').value !== 'clone') {
        readerDiv.classList.add('hidden');
      }
      if (scanBtn && document.getElementById('mode-select').value !== 'clone') scanBtn.style.display = 'none';
      if (cancelBtn && document.getElementById('mode-select').value !== 'clone') {
        cancelBtn.classList.add('hidden');
        cancelBtn.style.display = 'none';
      }
    }

    // Handle QR file upload for clone mode
    const cloneFileInput = document.getElementById('clone-file-input');
    if (cloneFileInput) {
      cloneFileInput.addEventListener('change', function(event) {
        const file = event.target.files && event.target.files[0];
        if (!file) return;

        if (!window.Html5Qrcode) {
          alert('QR scanner library not loaded.');
          return;
        }

        const html5QrcodeScanner = new Html5Qrcode("reader");
        
        html5QrcodeScanner.scanFile(file, true)
          .then((decodedText, decodedResult) => {
            // Try to decode if it's URL encoded, otherwise use as-is
            let decodedMessage;
            try {
              decodedMessage = decodeURIComponent(decodedText.trim());
            } catch (e) {
              // If decoding fails, use the original message
              decodedMessage = decodedText.trim();
            }
            const cleanedMessage = decodedMessage.replace(/[\x00-\x1F\x7F-\x9F]/g, '');
            const format = decodedResult.result.format.formatName || 'Unknown';
            document.getElementById('clone-input').value = cleanedMessage;
            generateQRCode(cleanedMessage, `Cloned from file [Format: ${format}]: `);
          })
          .catch(err => {
            const errorDetails = {
              type: err.name || 'Unknown',
              message: err.message || 'No error message',
              stack: err.stack || 'No stack trace',
              timestamp: new Date().toISOString()
            };
            console.error('QR scan failed:', errorDetails);
            logEntry(`File scan error: ${errorDetails.type} - ${errorDetails.message}`);
            alert('Could not decode QR code from image. Please try a clearer image.');
          })
          .finally(() => {
            html5QrcodeScanner.clear();
          });
      });
    }
  </script>
</body>
</html>
